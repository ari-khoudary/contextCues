---
title: "R Notebook"
output: html_notebook
editor_options: 
  chunk_output_type: console
---

## set up
```{r load packages}
library(tidyverse)
library(patchwork)
library(lme4)
library(lmerTest)
library(emmeans)
library(performance)
library(jtools) # for summarising model outputs
library(sjPlot)
library(MetBrewer)
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
```

```{r load & tidy inference data}
evidence_frames <- read.csv('../data/tidied/evidenceFrames.csv')  %>% rename(respFrame = response_frame)
inference_files = list.files('../data', full.names = TRUE, pattern='block1_inference.csv', recursive = TRUE)
inference_keep_idx <- grep('excluded', inference_files, invert=T)
inference_df = do.call(rbind, lapply(inference_files[inference_keep_idx], function(x) { read.csv(x, header = TRUE)} )) 

############### tidy inference data ############### 
inferenceData <- inference_df %>%
  filter(subID != 16) %>%
  rename(trueTarget = targetIdx) %>% 
  select(-c(noise1frames, noise2frames, signal1frames, block, targetImg, cue_rgb, cue_string)) %>%
  full_join(., evidence_frames, by=c('subID', 'trial', 'catch_trial', 'congruent', 'respFrame', 'response')) %>%
  mutate(subID = factor(subID),
         congruent = factor(as.character(congruent), levels=c("0", "NaN", "1"), labels=c('incongruent', 'neutral', 'congruent')),
         respFrame = ifelse(is.na(respFrame), 540, respFrame),
         cueIdx = case_when(trueTarget == 1 & congruent == 'congruent' ~ 1,
                            trueTarget == 1 & congruent == 'incongruent' ~ 2,
                            trueTarget == 1 & congruent == 'incongruent' ~ 2,
                            trueTarget == 2 & congruent =='congruent' ~ 2,
                            trueTarget == 2 & congruent=='incongruent' ~ 1,
                            congruent == 'neutral' ~ 3),
         cueType = ifelse(cueIdx==3, '50% cue', '80% cue'),
         totalNoise = noise1frames_behav + noise2frames_behav,
         totalTarget1 = rowSums(across(c(signal1_target1, signal2_target1)), na.rm=T),
         totalTarget2 = rowSums(across(c(signal1_target2, signal2_target2)), na.rm=T),
         trialTarget = case_when(totalTarget1 > totalTarget2 ~ 1,
                                 totalTarget1 < totalTarget2 ~ 2,
                                 totalTarget1 == totalTarget2 ~ NA),
         trialCongruence = case_when(cueIdx == trialTarget ~ 'congruent',
                                     cueIdx != trialTarget ~ 'incongruent',
                                     totalTarget1 == totalTarget2 ~ 'equal evidence'),
         trialCongruence = factor(trialCongruence, levels=c('incongruent', 'equal evidence', 'congruent')),
         firstNoiseRT = ifelse(respFrame <= noise1frames_design, 1, 0),
         secondNoiseRT = ifelse(respFrame > (noise1frames_design+signal1frames_design) & respFrame <= (noise1frames_design+signal1frames_design+noise2frames_design),
                                1, 0),
         firstSignalRT = ifelse(respFrame > noise1frames_design & respFrame <= (noise1frames_design+signal1frames_design), 1, 0),
         secondSignalRT = ifelse(respFrame > (noise1frames_design + signal1frames_design + noise2frames_design), 1, 0),
         respPeriod = case_when(firstNoiseRT==1 ~ 'noise1',
                                firstSignalRT==1 ~ 'signal1',
                                secondNoiseRT==1 ~ 'noise2',
                                secondSignalRT==1 ~ 'signal2'), 
         cueCongChoice = case_when(cueIdx==3 ~ NA, cueIdx==response ~ 1, cueIdx!=response ~ 0),
         evCongChoice = ifelse(response==trialTarget, 1, 0),
         firstNoise_quartile = cut(noise1frames_behav, breaks=quantile(noise1frames_behav, na.rm=T), include.lowest = T, labels=F), 
         secondNoise_quartile = cut(noise2frames_behav, breaks=quantile(noise2frames_behav, na.rm=T), include.lowest = T, labels=F), 
         totalNoise_quartile = cut(totalNoise, breaks=quantile(totalNoise, na.rm=T), include.lowest = T, labels=F),
         catch_trial_cat = factor(catch_trial, levels=c(0,1), labels=c('test', 'catch')),
         accuracy = case_when(rowSums(across(c(signal1_target1, signal2_target1)), na.rm=T) > rowSums(across(c(signal1_target2, signal2_target2)), na.rm=T) & response==1 ~ 1,
                                  rowSums(across(c(signal1_target1, signal2_target1)), na.rm=T) > rowSums(across(c(signal1_target2, signal2_target2)), na.rm=T) & response==2 ~ 0,
                                  rowSums(across(c(signal1_target1, signal2_target1)), na.rm=T) < rowSums(across(c(signal1_target2, signal2_target2)), na.rm=T) & response==2 ~ 1,
                                  rowSums(across(c(signal1_target1, signal2_target1)), na.rm=T) < rowSums(across(c(signal1_target2, signal2_target2)), na.rm=T) & response==1 ~ 0),
         accuracyFactor = factor(as.character(accuracy), levels=c("0", "1", "NaN"), labels=c('correct', 'incorrect', 'NA'))) %>%
  group_by(subID) %>%
  mutate(logRT = log(RT),
         zlogRT = scale(logRT),
         zConf = scale(confResp),
         logConfRT = log(confRT),
         zlogconfRT = scale(logConfRT), 
         rt_quartile = cut(zlogRT, breaks=quantile(zlogRT, na.rm=T), include.lowest=T, labels=F),
         trial_quartile = cut(trial, breaks=quantile(trial), include.lowest=T, labels=F)) %>%
  ungroup()

rm(inference_files, inference_keep_idx, evidence_frames, inference_df)
```

```{r make dfs for analysis}
inferenceData_tidy <- inferenceData %>%
  filter(is.na(response)==F) %>%
  mutate(chooseA = ifelse(response==1, 1, 0),
         chooseB = ifelse(response==1, 0, 1),
         cueType = factor(cueType),
         cueLabel = factor(cueIdx, levels=c('3', '1', '2'), labels=c('50%', '80% A', '80% B')),
         subID = factor(subID),
         respFinger = ifelse(chooseA==1, 1, 0),
         signal1_rawEv = case_when(chooseA==1 ~ signal1_target1,
                                   chooseB==1 ~ signal1_target2),
         signal1_relEv = case_when(chooseA==1 ~ signal1_target1 - signal1_target2,
                                   chooseB==1 ~ signal1_target2 - signal1_target1),
         signal1_relEv_z = scale(signal1_relEv),
         signal1_cueCong = case_when(cueIdx==1 & (signal1_target1 > signal1_target2) ~ '0.8 cue: congruent vizEv',
                                     cueIdx==1 & (signal1_target1 < signal1_target2) ~ '0.8 cue: incongruent vizEv',
                                     cueIdx==2 & (signal1_target1 > signal1_target2) ~ '0.8 cue: incongruent vizEv',
                                     cueIdx==2 & (signal1_target1 < signal1_target2) ~ '0.8 cue: congruent vizEv',
                                     cueIdx<3 & (signal1_target1 == signal1_target2) ~ '0.8 cue: equal vizEv',
                                     cueIdx==3 & (signal1_target1 > signal1_target2) ~ '0.5 cue: imgA vizEv',
                                     cueIdx==3 & (signal1_target1 < signal1_target2) ~ '0.5 cue: imgB vizEv',
                                     cueIdx==3 & (signal1_target1 == signal1_target2) ~ '0.5 cue: equal vizEv'),
         signal1_evCongChoice = case_when(signal1_target1 > signal1_target2 & response==1 ~ 1,
                                          signal1_target1 < signal1_target2 & response==2 ~ 1,
                                          signal1_target1 < signal1_target2 & response==1 ~ 0,
                                          signal1_target1 > signal1_target2 & response==2 ~ 0),
         signal2_cueCong = case_when(cueIdx==1 & (signal2_target1 > signal2_target2) ~ '0.8 cue: congruent vizEv',
                                     cueIdx==1 & (signal2_target1 < signal2_target2) ~ '0.8 cue: incongruent vizEv',
                                     cueIdx==2 & (signal2_target1 > signal2_target2) ~ '0.8 cue: incongruent vizEv',
                                     cueIdx==2 & (signal2_target1 < signal2_target2) ~ '0.8 cue: congruent vizEv',
                                     cueIdx<3 & (signal2_target1 == signal2_target2) ~ '0.8 cue: equal vizEv',
                                     cueIdx==3 & (signal2_target1 > signal2_target2) ~ '0.5 cue: imgA ev',
                                     cueIdx==3 & (signal2_target1 < signal2_target2) ~ '0.5 cue: imgB ev',
                                     cueIdx==3 & (signal2_target1 == signal2_target2) ~ '0.5 cue: equal ev'),
         signal2_cueCong = factor(signal2_cueCong),
         signal1_cueCong = factor(signal1_cueCong),
         noise1_seconds = noise1frames_behav * (1/60), 
         signal1RT = RT - noise1_seconds,
         vizLocked_respFrame = respFrame - noise1frames_behav,
         vizLocked_respFrame_t = vizLocked_respFrame / 60,
         vizLocked_sig2Resp = respFrame - (noise1frames_behav + signal1frames_behav + noise2frames_behav),
         vizLocked_sig2Resp = vizLocked_sig2Resp/60) %>% 
  group_by(subID) %>%
  mutate(noise1frames_z = scale(noise1frames_behav),
         noise2frames_z = scale(noise2frames_behav),
         totalNoise_z = scale(totalNoise),
         zlog_sig1RT = scale(log(signal1RT))) %>%
  ungroup()

# separate test & catch
test_trials <- inferenceData_tidy %>% filter(catch_trial==0)
catch_trials <- inferenceData_tidy %>% filter(catch_trial==1)

# all test trials that made it to second noise
noise2_df <- test_trials %>% 
  filter(respPeriod == 'noise2' | respPeriod =='signal2')
# non-neutral test trials that made it to second noise
noise2_nonNeutral <- noise2_df %>% 
  filter(congruent !='neutral')
```

```{r plotting setup: colors, outdir, functions}
# define plotting colors 
colors <- c('incongruent' = "#F8766D", 'neutral' = "#00BA38", 'congruent'="#619CFF")
trialCong_cols <- c('incongruent' = "#F8766D", 'equal evidence' = "lemonchiffon3", 'congruent'="#619CFF")
cueType_cols <- c('50%' = 'gray', '80%' = 'darkblue')
blues <- RColorBrewer::brewer.pal(9, "Blues")[c(4,5,6,7,8)]
cueCong_colors <- c('0.8 cue: incongruent vizEv' = "#F8766D", 
            '0.8 cue: equal vizEv' = "#00BA38", 
            '0.8 cue: congruent vizEv'="#619CFF",
            '0.5 cue: imgA vizEv' = 'purple',
            '0.5 cue: imgB vizEv' = 'orange',
            '0.5 cue: equal vizEv' = '#00BA38')

# where to save plots
outdir <- 'result_figures/'

# function for plotting effects of continuous predictors
varRange <- function(df, xVar, precision=1) {
  return(seq(min(df[,xVar], na.rm=T),
             max(df[,xVar], na.rm=T),
             precision))
}

noise2_x <- list(min(noise2_df$noise2frames_behav), median(noise2_df$noise2frames_behav), max(noise2_df$noise2frames_behav))
```

## expt specs
```{r duration distributions - design}
p1 <- inferenceData %>%
  ggplot(aes(x=noise1frames_design*1/60, fill=congruent, color=congruent)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'first noise durations')

p2 <- inferenceData %>%
  ggplot(aes(x=signal1frames_design*1/60, fill=congruent, color=congruent)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'first signal durations')

p3 <- inferenceData %>%
  ggplot(aes(x=noise2frames_design*1/60, fill=congruent, color=congruent)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'second noise durations')

p4 <- inferenceData %>%
  ggplot(aes(x=signal2frames_behav*1/60, fill=congruent, color=congruent)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'second signal durations', subtitle='defined as respFrame - sum(prev epoch durations)')

p1 + p2 + p3 + p4 + plot_layout(ncol=2, guides='collect') + plot_annotation(title = 'experimentally-designed epoch durations')

paste0(outdir, 'epochDurations.png') %>% ggsave(., width=10, height=6, dpi='retina')

rm(p1, p2, p3, p4)
```

```{r duration distributions - behavior}
p1 <- inferenceData %>%
  ggplot(aes(x=noise1frames_behav*1/60, fill=cueType)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'first noise durations') +
  scale_fill_manual(values = cueType_cols)

p2 <- inferenceData %>%
  ggplot(aes(x=signal1frames_behav*1/60, fill=cueType)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'first signal durations') +
  scale_fill_manual(values = cueType_cols)

p3 <- inferenceData %>%
  ggplot(aes(x=noise2frames_behav*1/60, fill=cueType)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'second noise durations') +
  scale_fill_manual(values = cueType_cols)

p4 <- inferenceData %>%
  ggplot(aes(x=signal2frames_behav*1/60, fill=cueType)) +
  theme_classic() +
  geom_bar(position=position_dodge()) +
  scale_x_binned() +
  labs(y = 'number of trials', x = 'duration (seconds)', title = 'second signal durations', subtitle='defined as respFrame - sum(prev epoch durations)') + 
  scale_fill_manual(values = cueType_cols)

p1 + p2 + p3 + p4 + plot_layout(ncol=2, guides='collect') + plot_annotation(title = 'behaviorally-induced epoch durations')

#paste0(outdir, 'epochDurations_behavior.png') %>% ggsave(., width=10, height=6, dpi='retina')

rm(p1, p2, p3, p4)
```

```{r response distribution}
##### experimenter-defined congruence
nTrials <- inferenceData %>% group_by(cueType, catch_trial_cat) %>% count() %>% rename(totalTrials = n)
respTrials <- inferenceData %>% group_by(cueType, catch_trial_cat, respPeriod) %>% count()

left_join(respTrials, nTrials, by=c('cueType', 'catch_trial_cat')) %>%
  group_by(cueType, respPeriod) %>%
  mutate(pResp = n/totalTrials,
         respPeriod = factor(respPeriod, levels=c('noise1', 'signal1', 'noise2', 'signal2'))) %>%
  ggplot(aes(x=respPeriod, y=pResp, fill=cueType)) +
  theme_bw() + 
  facet_wrap(~ catch_trial_cat) +
  geom_col(position = position_dodge()) + 
  labs(y = 'proportion of trials', x='', title='proportion of responses made in each trial period') +
  scale_fill_manual(values = c('gray', 'darkblue'))

paste0(outdir, 'respPeriods_coarse.png') %>% ggsave(width=8, height=4, dpi='retina')
rm(nTrials, respTrials)

##### experienced congruence
nTrials <- inferenceData %>% group_by(trialCongruence, catch_trial_cat) %>% count() %>% rename(totalTrials = n)
respTrials <- inferenceData %>% group_by(trialCongruence, catch_trial_cat, respPeriod) %>% count()

left_join(respTrials, nTrials, by=c('trialCongruence', 'catch_trial_cat')) %>%
  group_by(trialCongruence, respPeriod) %>%
  mutate(pResp = n/totalTrials,
         respPeriod = factor(respPeriod, levels=c('noise1', 'signal1', 'noise2', 'signal2')),
         trialCongruence = factor(trialCongruence, levels=c('equal evidence', 'congruent', 'incongruent'))) %>%
  ggplot(aes(x=respPeriod, y=pResp, fill=trialCongruence)) +
  theme_bw() +
  facet_wrap(~ catch_trial_cat) +
  geom_col(position = position_dodge()) +
  ylim(0, 1) +
  labs(y = 'proportion of trials', x='', title='proportion of responses made in each trial period') +
  scale_fill_manual(values=trialCong_cols)

paste0(outdir, 'respPeriods_evCong.png') %>% ggsave(width=8, height=4, dpi='retina')
rm(nTrials, respTrials)
```

## static results
```{r p(chooseA | cue)}

### summary stats ###
p0 <- test_trials %>%
  group_by(subID, cueIdx) %>%
  summarise(pChooseA = mean(chooseA)) %>%
  ggplot(aes(x=cueIdx, y=pChooseA)) +
  theme_bw() +
  geom_hline(yintercept = 0.5) +
  stat_summary(fun = 'mean', geom='col', fill='lightblue') +
  stat_summary(fun.data = 'mean_se', geom='pointrange') +
  labs(title = 'summary stats from the data', x='cue', y='proportion of choices==1', subtitle='errobars: +/- 1 SEM') +
  ylim(0,1)

### logistic regression - effects coding
m1 <- glmer(chooseA ~ cueIdx + (1|subID), data=test_trials, contrasts=list(cueIdx=contr.sum), family = binomial(link = 'logit'))
m1_emm <- emmeans(m1, 'eff' ~ cueIdx, type='response')

# plot raw coefficients
p1 <- emmeans(m1, 'eff' ~ cueIdx)$contrasts %>%
  as.data.frame() %>%
  ggplot(aes(x=contrast, y=estimate)) +
  geom_hline(yintercept=0, linetype='dashed') +
  geom_pointrange(aes(ymin = estimate - (1.96*SE), ymax = estimate + (1.96*SE)), fatten=7) +
  theme_bw() +
  labs(title='raw coefficient values', y='estimate (log odds)', x='', subtitle='errorbars: 1.96 * SE (Wald method)')

# plot transformed coefficients
p2 <- m1_emm$contrasts %>% 
  as.data.frame() %>%
  ggplot(aes(x=contrast, y=odds.ratio)) +
  geom_hline(yintercept=1, linetype='dashed') +
  geom_pointrange(aes(ymin = odds.ratio - (1.96*SE), ymax = odds.ratio + (1.96*SE)), fatten=7) +
  ylim(-1, 3) + 
  theme_bw() +
  labs(title='back-transformed coefficient values', y='estimate (odds ratio)', x='', subtitle='errorbars: 1.96 * SE (Wald method)')
  
# plot marginal means on response scale
p3 <- m1_emm$emmeans %>%
  as.data.frame() %>%
  ggplot(aes(x=cueIdx, y=prob)) +
  theme_bw() +
  geom_hline(yintercept=0.5, linetype='dashed') +
  geom_col(color='lightblue', fill='white', linewidth=2) +
  geom_jitter(aes(y=chooseA), test_trials, color='lightblue', alpha=0.5, size=1, height=0.05) +
  geom_pointrange(aes(ymin=asymp.LCL, ymax=asymp.UCL), fatten=5) +
  labs(x='', y='expected marginal mean: p(chooseA)', title='expected marginal means on the response scale', subtitle='errorbars: 95% confidence intervals')

p1 + p2 + p3 + p0 + plot_layout(nrow=2, ncol=2, widths=c(1,1,1.5,1.5)) & plot_annotation(title = 'Effects/sum-to-zero coded regression results: chooseA ~ cueIdx + (1|subID)')
paste0(outdir, 'pChooseA_reg.png') %>% ggsave(width=9, height=6, dpi='retina')
rm(p1, p2, p3, p0, m1, m1_emm)
```

```{r p(chooseB | cue)}

### summary stats ###
p0 <- test_trials %>%
  group_by(subID, cueIdx) %>%
  summarise(pChooseB = mean(chooseB)) %>%
  ggplot(aes(x=cueIdx, y=pChooseB)) +
  theme_bw() +
  geom_hline(yintercept = 0.5) +
  stat_summary(fun = 'mean', geom='col', fill='lightcoral') +
  stat_summary(fun.data = 'mean_se', geom='pointrange') +
  labs(title = 'summary stats from the data', x='cue', y='proportion of choices==1', subtitle='errobars: +/- 1 SEM') +
  ylim(0,1)

### logistic regression - effects coding
m1 <- glmer(chooseB ~ cueIdx + (1|subID), data=test_trials, contrasts=list(cueIdx=contr.sum), family = binomial(link = 'logit'))
m1_emm <- emmeans(m1, 'eff' ~ cueIdx, type='response')

# plot raw coefficients
p1 <- emmeans(m1, 'eff' ~ cueIdx)$contrasts %>%
  as.data.frame() %>%
  ggplot(aes(x=contrast, y=estimate)) +
  geom_hline(yintercept=0, linetype='dashed') +
  geom_pointrange(aes(ymin = estimate - (1.96*SE), ymax = estimate + (1.96*SE)), fatten=7) +
  theme_bw() +
  labs(title='raw coefficient values', y='estimate (log odds)', x='', subtitle='errorbars: 1.96 * SE (Wald method)')

# plot transformed coefficients
p2 <- m1_emm$contrasts %>% 
  as.data.frame() %>%
  ggplot(aes(x=contrast, y=odds.ratio)) +
  geom_hline(yintercept=1, linetype='dashed') +
  geom_pointrange(aes(ymin = odds.ratio - (1.96*SE), ymax = odds.ratio + (1.96*SE)), fatten=7) +
  ylim(-1, 3) + 
  theme_bw() +
  labs(title='back-transformed coefficient values', y='estimate (odds ratio)', x='', subtitle='errorbars: 1.96 * SE (Wald method)')
  
# plot marginal means on response scale
p3 <- m1_emm$emmeans %>%
  as.data.frame() %>%
  ggplot(aes(x=cueIdx, y=prob)) +
  theme_bw() +
  geom_hline(yintercept=0.5, linetype='dashed') +
  geom_col(color='lightcoral', fill='white', linewidth=2) +
  geom_jitter(aes(y=chooseB), test_trials, color='lightcoral', alpha=0.5, size=1, height=0.05) +
  geom_pointrange(aes(ymin=asymp.LCL, ymax=asymp.UCL), fatten=5) +
  labs(x='', y='expected marginal mean: p(chooseB)', title='expected marginal means on the response scale', subtitle='errorbars: 95% confidence intervals')

p1 + p2 + p3 + p0 + plot_layout(nrow=2, ncol=2, widths=c(1,1,1.5,1.5)) & plot_annotation(title = 'Effects/sum-to-zero coded regression results: chooseB ~ cueIdx + (1|subID)')
paste0(outdir, 'static_results/pChooseB_reg.png') %>% ggsave(width=9, height=6, dpi='retina')
rm(p1, p2, p3, p0, m1, m1_emm)
```

```{r zlogRT | cue}
### plot distributions
p1 <- test_trials %>%
  ggplot(aes(x=RT)) +
  theme_bw() +
  geom_vline(xintercept = mean(test_trials$RT), linetype='dotted') +
  facet_wrap(~ cueIdx) + 
  geom_density(fill='lightblue',alpha=0.7) +
  labs(title='raw RTs - dashed line represents grand mean')

p2 <- test_trials %>%
  ggplot(aes(x=zlogRT)) +
  theme_bw() +
  geom_vline(xintercept=0, linetype='dotted') +
  facet_wrap(~ cueIdx) + 
  geom_density(fill='lightblue',alpha=0.7) +
  labs(title='zlogged RTs')


### run effects-coded regression
m2 <- lm(zlogRT ~ cueIdx, test_trials, contrasts=list(cueIdx=contr.sum))
m2_emm <- emmeans(m2, 'eff' ~ cueIdx)

# compute grand mean across conditions
groupMeans <- test_trials %>% group_by(cueIdx) %>% summarise(meanRT = mean(zlogRT))
grandMean = mean(groupMeans$meanRT)

# plot coefficients
p3 <- m2_emm$contrasts %>%
  as.data.frame() %>%
  ggplot(aes(x=contrast, y=estimate)) +
  geom_hline(yintercept=grandMean, linetype='dashed') +
  geom_pointrange(aes(ymin=estimate- (1.96*SE), ymax = estimate+(1.96*SE))) +
  theme_bw() +
  labs(title='coefficient values: effects-coded', x='', subtitle='errorbars: 1.96 * SE (Wald method); dashed line = grand mean')

# plot emmeans
p4 <- m2_emm$emmeans %>%
  as.data.frame() %>%
  ggplot(aes(x=cueIdx, y=emmean)) +
  geom_hline(yintercept=0, linetype='dashed') +
  geom_violin(aes(x=cueIdx, y=zlogRT), test_trials, fill='lightblue', alpha=0.75, width = 0.5) +
  geom_pointrange(aes(ymin=lower.CL, ymax = upper.CL)) +
  theme_bw() +
  labs(title='expected marginal means: effects-coded', x='', subtitle='errorbars: 95% confidence intervals', y='mean zlogRT')

### run dummy-coded regression
m2_dummy <- lm(zlogRT ~ cueIdx, test_trials)
m2_dummy_em <- emmeans(m2_dummy, 'trt.vs.ctrl' ~ cueIdx)

# plot coefficients
p5 <- m2_dummy_em$contrasts %>%
  as.data.frame() %>%
  ggplot(aes(x=contrast, y=estimate)) +
  geom_hline(yintercept=mean(test_trials$zlogRT[test_trials$congruent=='neutral']), linetype='dashed') +
  geom_pointrange(aes(ymin=estimate- (1.96*SE), ymax = estimate+(1.96*SE))) +
  theme_bw() +
  ylim(-1, 1) + 
  labs(title='coefficient values: dummy-coded', x='', subtitle='errorbars: 1.96 * SE (Wald method); dashed line = mean of neutral zlogRTs')

# plot emmeans
p6 <- m2_dummy_em$emmeans %>%
  as.data.frame() %>%
  ggplot(aes(x=cueIdx, y=emmean)) +
  geom_hline(yintercept = 0, linetype='dashed') +
  theme_bw() +
  geom_violin(aes(y=zlogRT, x=cueIdx), test_trials, fill='lightblue', alpha=0.75, width=0.5) +
  geom_pointrange(aes(ymin=lower.CL, ymax=upper.CL)) +
  labs(y='mean zlogRT', x='', title='expected marginal means: dummy-coded', subtitle='errorbars: 95% confidence intervals')

(p3 + p5) / (p4 + p6) / (p1 + p2)

paste0(outdir, 'RT_reg.png') %>% ggsave(height=9, width=12, dpi='retina')

rm(p1, p2, p3, p4, p5, p6, groupMeans, grandMean, m2, m2_emm, m2_dummy, m2_dummy_em)
```

```{r zlogRT ~ noise1frames * cueType}

inferenceData_tidy %>%
  filter(respPeriod == 'noise1') %>%
  lm(zlogRT ~ noise1frames_behav * cueType, .) %>% 
  emtrends(., pairwise ~ cueType, var='noise1frames_behav')

%>%
  emtrends(., ~ cueType, var='noise1frames_behav') %>%
  emmip(., ~ noise1frames_behav | cueType)


```

## noise 2 analyses
```{r p(chooseCue | noise2 duration)}
# plot raw data
p1 <- noise2_nonNeutral %>%
  group_by(subID, secondNoise_quartile) %>%
  summarise(pCue = mean(cueCongChoice)) %>%
  filter(is.na(secondNoise_quartile)==F) %>%
  ggplot(aes(y=pCue, x=secondNoise_quartile, label=subID)) +
  theme_bw() +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  geom_line(aes(group=subID, color=factor(subID)), alpha=0.5, linewidth=1) +
  stat_summary(fun.data='mean_se', geom='pointrange', fatten=6) +
  labs(y = 'proportion of choices == cue', title = 'summary stats on raw data', subtitle='errorbars: +/- 1 SEM')

# plot simple linear regression
p2 <- noise2_nonNeutral %>%
  ggplot(aes(x=noise2frames_behav, y=cueCongChoice)) +
  theme_bw() +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
  labs(title='logistic regression: all subjects', subtitle= 'cueCongChoice ~ noise2frames')

# plot single regression per subject
p3 <- noise2_nonNeutral %>% 
  mutate(subID = paste0('subID=', subID)) %>%
  ggplot(aes(x=noise2frames_behav, y=cueCongChoice)) +
  theme_bw() +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  facet_wrap(~ subID, nrow=2) +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) +
  labs(title='logistic regression: one per subject', subtitle= 'cueCongChoice ~ noise2frames')

(p1 + p2) / p3 + plot_layout(heights=c(0.75, 2)) + plot_annotation(title = 'Probability of making a cue-congruent response as a function of second noise duration',
                                                                subtitle = '80% cues only')

paste0(outdir, 'noise2_regressions/simple_cueCong.png') %>% ggsave(width=8, height=8, dpi='retina')

rm(p1, p2, p3)

### repeat the same analysis but with z-scored noise 2 duration
# group
# noise2_nonNeutral %>%
#   ggplot(aes(x=noise2frames_z, y=cueCongChoice)) +
#   theme_bw() +
#   geom_point(shape='|') +
#   geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
#   labs(title='logistic regression', subtitle= 'cueCongChoice ~ noise2frames')
# 
# # individual
# noise2_nonNeutral %>% 
#   mutate(subID = paste0('subID=', subID)) %>%
#   ggplot(aes(x=noise2frames_z, y=cueCongChoice)) +
#   theme_bw() +
#   facet_wrap(~ subID, nrow=2) +
#   geom_point(shape='|') +
#   geom_smooth(method = 'glm', method.args=list(family='binomial')) +
#   labs(title='generalized linear regression', subtitle= 'cueCongChoice ~ noise2frames')
# 
# ### repeat the same analysis but with the experimenter-defined noise 2 duration
# noise2_nonNeutral %>%
#   mutate(noise2_quartile = cut(noise2frames_design, quantile(noise2frames_design, labels=F))) %>%
#   group_by(subID, noise2_quartile) %>%
#   summarise(pCue = mean(cueCongChoice)) %>%
#   filter(is.na(noise2_quartile)==F) %>%
#   ggplot(aes(y=pCue, x=noise2_quartile, label=subID)) +
#   theme_bw() +
#   geom_hline(yintercept = 0.5, linetype='dashed') +
#   geom_line(aes(group=subID, color=factor(subID)), alpha=0.5, linewidth=1) +
#   stat_summary(fun.data='mean_se', geom='pointrange', fatten=6) +
#   #geom_text(vjust=-0.5, hjust=0.3) +
#   labs(y = 'proportion of choices == cue', title = 'summary stats on raw data', subtitle='errorbars: +/- 1 SEM')
# 
# # plot simple linear regression
# noise2_nonNeutral %>%
#   ggplot(aes(x=noise2frames_design, y=cueCongChoice)) +
#   theme_bw() +
#   geom_point(shape = '|') +
#   geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
#   labs(title='generalized linear regression', subtitle= 'cueCongChoice ~ noise2frames')
# 
# # plot single regression per subject
# noise2_nonNeutral %>% 
#   mutate(subID = paste0('subID=', subID)) %>%
#   ggplot(aes(x=noise2frames_design, y=cueCongChoice)) +
#   theme_bw() +
#   facet_wrap(~ subID, nrow=2) +
#   geom_point(shape='|') +
#   geom_smooth(method = 'glm', method.args=list(family='binomial')) +
#   labs(title='generalized linear regression', subtitle= 'cueCongChoice ~ noise2frames')
# paste0(outdir, 'noise2_regPerSubject.png') %>% ggsave(width=8, height=6, dpi='retina')


##### OLD -- I TRIED TO GO BESPOKE BUT I SHOULD JUST USE PACKAGES INSTEAD ##### 
##### mixed-effects regression doesn't necessarily give you an effect per-subject; it constrains its estimates based on the hierarchical structure ####
# m3 <- glmer(cueCongChoice ~ noise2frames_z + (1|subID), noise2_nonNeutral, 
#             family = binomial(link = 'logit'), glmerControl(optimizer = 'bobyqa'))
# summary(m3)
# plot results
# noise2_nonNeutral %>%
#   mutate(fit.c = predict(m3, re.form=NULL)) %>%
#   ggplot(aes(x=noise2frames_behav, y=cueCongChoice)) +
#   theme_bw() +
#   facet_wrap(~ subID, nrow=2) +
#   geom_point(shape='|') +
#   geom_line(aes(y=fit.c)) 
# 
# ## fit one line per subject
# noise2_nonNeutral %>%
#   ggplot(aes(x=noise2frames_z, y=cueCongChoice)) +
#   theme_bw() +
#   facet_wrap(~ subID, nrow=2) +
#   geom_point(shape='|') +
#   stat_smooth(method = 'glm', method.args=list(family=binomial(link = 'logit')))

# extract & transform results
# m3_coef <- as.data.frame(coef(m3)$subID) %>% mutate(subID = rownames(.)) %>% rename('intercept' = '(Intercept)')
# m3_coef <- m3_coef %>% mutate(transInt = plogis(intercept),
#                           transSlope = plogis(noise2frames_behav)) %>% 
#   select(subID, transInt, transSlope)
# 
# noise2_nonNeutral <- noise2_nonNeutral %>% left_join(m3_coef, by='subID') %>% mutate(lineVal = transSlope*(noise2frames_behav/100) + transInt)
# 
# # plot individual effects
# noise2_nonNeutral %>%
#   mutate(noise2frames_behav = noise2frames_behav/100) %>%
#   ggplot(aes(x=noise2frames_behav, y=cueCongChoice)) +
#   theme_bw() +
#   facet_wrap(~ subID, nrow=2) +
#   geom_point(shape='|') +
#   geom_point(aes(y=lineVal, x=noise2frames_behav))
```

```{r p(respIdx | cue) ~ noise2 duration}

# group chooseA
p1 <- noise2_df %>% 
  mutate(cueIdx = paste0('cue=', cueIdx)) %>%
  ggplot(aes(x=noise2frames_behav, y=chooseA)) + 
  facet_wrap(~ cueIdx) + 
  theme_bw() +
  geom_point(shape='|') +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
  labs(title='logistic regression: p(chooseA)', subtitle= 'chooseA ~ noise2frames')

# group chooseB
p2 <- noise2_df %>% 
  mutate(cueIdx = paste0('cue=', cueIdx)) %>%
  ggplot(aes(x=noise2frames_behav, y=chooseB)) + 
  facet_wrap(~ cueIdx) + 
  theme_bw() +
  geom_point(shape='|') +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  geom_smooth(method = 'glm', method.args=list(family='binomial'), color='coral1') + 
  labs(title='logistic regression: p(chooseB)', subtitle= 'chooseB ~ noise2frames')
  
p1 / p2

paste0(outdir, 'noise2_regressions/chooseResp.png') %>% ggsave(width=6, height=6, dpi='retina')

rm(p1, p2)
```

```{r p(chooseEv) ~ cueType * noise2duration + respFinger -- CUE W/O CONGRUENCE INFO}

m6 <- glm(signal1_evCongChoice ~ cueType * noise2frames_behav + respFinger, noise2_df, family='binomial', contrasts=list(cueType=contr.sum))

emmip(m6, ~ noise2frames_behav | cueType, type='response',
      at=list(noise2frames_behav = varRange(noise2_nonNeutral,'noise2frames_behav', precision=0.5)), plotit = F) %>%
  as.data.frame() %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  facet_wrap(~ cueType) +
  geom_hline(yintercept=0.5,linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.2) +
  geom_line(linewidth=2) +
  scale_color_gradient2() +
  labs(y = 'p(chooseEvidence-Dominant)', x = 'noise2 frames', title = 'logistic regression on p(chooseEvidence)', subtitle= 'signal1_evCongChoice ~ cueType * noise2frames + respFinger') 

#paste0(outdir, 'noise2_regressions/pChooseEv_cueOnly.png') %>% ggsave(width=5, height=3, dpi='retina')
```

```{r p(chooseEv) ~ signal1_cueCong * noise2duration + respFinger -- CUE W/ CONGRUENCE INFO}
m7 <- glm(signal1_evCongChoice ~ signal1_cueCong * noise2frames_behav + respFinger, 
          noise2_df, family='binomial', contrasts=list(signal1_cueCong=contr.sum))

emmip(m7,  ~ noise2frames_behav | signal1_cueCong, type='response',
      at=list(noise2frames_behav = varRange(noise2_nonNeutral,'noise2frames_behav', precision=0.5)), plotit = F) %>%
  as.data.frame() %>%
  ggplot(aes(x=xvar, y=yvar, color = signal1_cueCong, fill=signal1_cueCong)) +
  theme_bw() +
  #facet_wrap(~ cueType) +
  geom_hline(yintercept=0.5,linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.2, color=NA) +
  geom_line(linewidth=2) +
  labs(y = 'p(chooseEvidence-Dominant)', x = 'noise2 frames', title = 'logistic regression on p(chooseEvidenceDominantImage)', subtitle= 'signal1_evCongChoice ~ signal1_cueCong * noise2frames + respFinger') 

paste0(outdir, 'noise2_regressions/pChooseEv_cueCong.png') %>% ggsave(width=6, height=4, dpi='retina')
```

```{r p(chooseEv) ~ cueType * signal1_cueCong * noise2 duration + respFinger}
# run regression
m5 <- glm(evCongChoice ~ cueType * signal1_cueCong * noise2frames_behav, noise2_df, family='binomial')

# get dataframe with everything needed to plot
m5_df <- emmip(m5,  signal1_cueCong ~ noise2frames_behav | cueType, type='response', 
      at=list(noise2frames_behav = varRange(noise2_nonNeutral,'noise2frames_behav', precision=5)),
      plotit = F) %>% as.data.frame()

m5_df %>%
  ggplot(aes(x=xvar, y=yvar, fill=signal1_cueCong, color=signal1_cueCong)) +
  theme_bw() +
  facet_wrap(~ cueType) +
  geom_hline(yintercept=0.5,linetype='dashed') +
  geom_line(linewidth=2) +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_cueCong), alpha=0.1, color=NA) +
  #labs(y = 'p(chooseCue)', x = 'noise2 frames', title = 'logistic regression on p(chooseCue): 80% trials', subtitle= 'chooseCue ~ noise2frames * signal1_cueCong + respFinger') +
  ylim(0,1) +
  theme(legend.position = 'bottom')

paste0(outdir, 'noise2_regressions/pChooseCue_evCong.png') %>% ggsave(width=4, height=4, dpi='retina')
rm(m4, m4_df)
```

```{r p(chooseEv) ~ cueType * signal1_relEv * noise2duration + respFinger}

m5 <- glm(signal1_evCongChoice ~ signal1_evCong * signal1_relEv * noise2frames_behav + respFinger, noise2_df, family='binomial', contrasts=list(cueType=contr.sum))

emmip(m5, signal1_relEv ~ noise2frames_behav | cueType, type='response', 
      at=list(noise2frames_behav = varRange(noise2_nonNeutral,'noise2frames_behav', precision=5),
                signal1_relEv = varRange(noise2_nonNeutral, 'signal1_relEv', precision=20)),
      plotit = F) %>%
  as.data.frame() %>%
  ggplot(aes(x=xvar, y=yvar, group=signal1_relEv, fill=signal1_relEv, color=signal1_relEv)) +
  theme_bw() +
  facet_wrap(~ cueType) +
  geom_hline(yintercept=0.5,linetype='dashed') +
  geom_line(linewidth=2) +
  scale_color_gradient2() +
  labs(y = 'p(chooseEvidence-Dominant)', x = 'noise2 frames', title = 'logistic regression on p(chooseEvidence-dominantImage)', subtitle= 'evCongChoice ~ cueType*noise2frames * signal1_relEv + respFinger') 

paste0(outdir, 'noise2_regressions/pChooseEv_allCues.png') %>% ggsave(width=8, height=4, dpi='retina')
```

```{r p(chooseCue) ~ signal1_relEv * noise2 duration + respFinger}
# run regression
m4 <- glm(cueCongChoice ~ signal1_relEv * noise2frames_behav + respFinger, noise2_nonNeutral, family='binomial')

# get dataframe with everything needed to plot
m4_df <- emmip(m4, signal1_relEv ~ noise2frames_behav, type='response', 
      at=list(noise2frames_behav = varRange(noise2_nonNeutral,'noise2frames_behav', precision=5),
                signal1_relEv = varRange(noise2_nonNeutral, 'signal1_relEv', precision=5)),
      plotit = F) %>% as.data.frame()

m4_df %>%
  ggplot(aes(x=xvar, y=yvar, group=signal1_relEv, fill=signal1_relEv, color=signal1_relEv)) +
  theme_bw() +
  geom_hline(yintercept=0.5,linetype='dashed') +
  geom_line(linewidth=2) +
  #geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_relEv), alpha=0.2, color=NA) +
  scale_color_gradient2() +
  labs(y = 'p(chooseCue)', x = 'noise2 frames', title = 'logistic regression on p(chooseCue): 80% trials', subtitle= 'chooseCue ~ noise2frames * signal1_relEv + respFinger') +
  ylim(0,1) 

paste0(outdir, 'noise2_regressions/pChooseCue.png') %>% ggsave(width=6, height=4, dpi='retina')
rm(m4, m4_df)
```

```{r p(chooseCue) ~ signal1_cueCong * noise2 duration + respFinger}
# run regression
m4 <- glm(cueCongChoice ~ cueTypesignal1_cueCong * noise2frames_behav + respFinger, noise2_nonNeutral, family='binomial')

# get dataframe with everything needed to plot
m4_df <- emmip(m4, ~ noise2frames_behav | signal1_cueCong, type='response', 
      at=list(noise2frames_behav = varRange(noise2_nonNeutral,'noise2frames_behav', precision=5)),
      plotit = F) %>% as.data.frame()

m4_df %>%
  mutate(signal1_cueCong = factor(signal1_cueCong, 
                                  levels=c('cue-incongruent evidence', 'equal evidence', 'cue-congruent evidence'),
                                  labels=c('cue-incong', 'equal', 'cue-cong'))) %>%
  ggplot(aes(x=xvar, y=yvar, group=signal1_cueCong, fill=signal1_cueCong, color=signal1_cueCong)) +
  theme_bw() +
  geom_hline(yintercept=0.5,linetype='dashed') +
  geom_line(linewidth=2) +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_cueCong), alpha=0.1, color=NA) +
  labs(y = 'p(chooseCue)', x = 'noise2 frames', title = 'logistic regression on p(chooseCue): 80% trials', subtitle= 'chooseCue ~ noise2frames * signal1_cueCong + respFinger') +
  ylim(0,1) +
  theme(legend.position = 'bottom',
        text = element_text(size=8))

paste0(outdir, 'noise2_regressions/pChooseCue_evCong.png') %>% ggsave(width=4, height=4, dpi='retina')
rm(m4, m4_df)
```

```{r p(chooseCue) ~ signal1_cueCong * noise2 duration + respFinger}
# run regression
m <- glm(cueCongChoice ~ noise2Onset * signal1_cueCong * noise2frames_behav + respFinger, noise2_nonNeutral, family='binomial')

# get estimates for min, median, 75% quartile, and max noise2 duration

noise2_range <- sort(c(range(noise2_nonNeutral$noise2Onset), median(noise2_nonNeutral$noise2Onset), quantile(noise2_nonNeutral$noise2Onset, names=F)[4]))

# get dataframe with everything needed to plot
m_df <- emmip(m, noise2Onset ~ noise2frames_behav | signal1_cueCong, type='response',
      at=list(noise2frames_behav = quantile(noise2_nonNeutral$noise2frames_behav, labels=F),
              noise2Onset = quantile(noise2_nonNeutral$noise2Onset)), plotit = F) %>%
  as.data.frame()

m_df %>%
  filter(noise2Onset != 115) %>%
  mutate(signal1_cueCong = factor(signal1_cueCong, levels=c('0.8 cue: incongruent evidence',
                                                            '0.8 cue: equal evidence',
                                                            '0.8 cue: congruent evidence')),
         noise2Onset = factor(noise2Onset, levels = noise2_range, labels=c('min', 'median', '75% q', 'max'))) %>%
  ggplot(aes(xvar, yvar, group=noise2Onset)) + 
  theme_bw() +
  geom_hline(yintercept=0.5, linetype='dashed') +
  facet_wrap(~ signal1_cueCong) +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_cueCong), alpha=0.1, color=NA) +
  geom_line(aes(linewidth=noise2Onset, color=signal1_cueCong)) +
  labs(y = 'p(chooseCue)', x='noise2frames', title = 'chooseCue ~ noise2Onset * signal1_cueCong * noise2frames_behav + respFinger',
       subtitle = 'at min, median, 75% quartile, and max durations of noise2Onset') +
  scale_linewidth_manual(values = c(0.5,1,1.35,1.65))

paste0(outdir, 'noise2_regressions/pChooseCue_evCong_noiseOnset.png') %>% ggsave(width=8, height=4, dpi='retina')
```

```{r RT ~ signal1_cueCong * noise2 duration + respFinger}

m <- noise2_df %>% filter(respPeriod=='signal2') %>%
  lmer(zlogRT ~ signal1_cueCong * noise2frames_behav + respFinger + (1|subID), .)

emmip(m, signal1_cueCong ~ noise2frames_behav, at=list(noise2frames_behav = noise2_range), plotit=F) %>%
  mutate(cueType = case_when(str_starts(signal1_cueCong, '0.5') ~ '50% cue',
                             str_starts(signal1_cueCong, '0.8') ~ '80% cue'),
         signal1_cueCong = factor(signal1_cueCong, levels=c('0.5 cue: imgA vizEv', '0.5 cue: imgB vizEv', '0.5 cue: equal vizEv',
                                                            '0.8 cue: incongruent vizEv', '0.8 cue: congruent vizEv', '0.8 cue: equal vizEv'))) %>%
  ggplot(aes(xvar, yvar, group=signal1_cueCong, color=signal1_cueCong, fill=signal1_cueCong)) + 
  theme_bw() +
  geom_hline(yintercept=1) +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), color=NA, alpha=0.1) +
  geom_line(linewidth=1) +
  scale_fill_manual(values=met.brewer("Lakota")) + scale_color_manual(values=met.brewer("Lakota")) +
  facet_wrap(~ cueType) +
  labs(y='zlogRT (estimated)', x='noise2 duration', title='zlogRT ~ signal1_cueCong * noise2frames + respFinger', subtitle='effect of noise on RTs in second signal, ignoring congruence of s2 evidence w/ cue')

paste0(outdir, 'noise2_regressions/sig2RT_noise2frames*signal1cueCong.png') %>% ggsave(width=8, height=4, dpi='retina')
```

```{r RT ~ signal1_cueCong * noise2 duration * signal2_cueCong + respFinger}

m <- noise2_df %>% filter(respPeriod=='signal2') %>%
  lmer(vizLocked_sig2Resp ~ signal1_cueCong * noise2frames_behav * signal2_cueCong + respFinger + (1|subID), .)

m_df <- emmip(m, signal1_cueCong * signal2_cueCong ~ noise2frames_behav, at=list(noise2frames_behav=noise2_range), plotit=F) %>%
  filter(is.na(yvar)==F) %>%
  mutate(cueType = case_when(str_starts(signal1_cueCong, '0.5') ~ '50% cue',
                             str_starts(signal1_cueCong, '0.8') ~ '80% cue'))


p1 <- m_df %>%
  filter(cueType == '80% cue') %>% 
  mutate(signal2_cueCong = factor(signal2_cueCong, levels=c('0.8 cue: equal vizEv', '0.8 cue: congruent vizEv', '0.8 cue: incongruent vizEv')),
         signal1_cueCong = factor(signal1_cueCong, levels=c('0.8 cue: equal vizEv', '0.8 cue: congruent vizEv', '0.8 cue: incongruent vizEv')),
         signal1_cueCong = paste0('signal1 ', signal1_cueCong)) %>%
  ggplot(aes(xvar, yvar, group=signal2_cueCong, color=signal2_cueCong, fill=signal2_cueCong)) + 
  theme_bw() +
  geom_hline(yintercept=1) +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), color=NA, alpha=0.1) +
  geom_line(linewidth=1) +
  facet_wrap(~ signal1_cueCong, scales = 'free') +
  scale_color_manual(values = cueCong_colors) + scale_fill_manual(values = cueCong_colors) +
  labs(y='zlogRT (estimated)', x='noise2 duration', subtitle='zlogRT ~ signal1_cueCong * noise2frames * signal2_cueCong + respFinger', title='80% cue: effect of cue-evidence congruence & noise2 duration on RTs')

p2 <- m_df %>%
   filter(cueType == '50% cue') %>% 
   mutate(signal1_cueCong = paste0('signal1 ', signal1_cueCong)) %>%
    ggplot(aes(xvar, yvar, group=signal2_cueCong, color=signal2_cueCong, fill=signal2_cueCong)) + 
    theme_bw() +
    geom_hline(yintercept=1) +
    geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), color=NA, alpha=0.1) +
    geom_line(linewidth=1) +
    facet_wrap(~ signal1_cueCong, scales='free') +
    #scale_fill_manual(values=cueCong_colors) + scale_color_manual(values=cueCong_colors) +
    labs(y='zlogRT (estimated)', x='noise2 duration', subtitle='zlogRT ~ signal1_cueCong * noise2frames * signal2_cueCong + respFinger', title='50% cue: effect of cue-evidence congruence & noise2 duration on RTs')

p1 / p2

paste0(outdir, 'noise2_regressions/sig2RT_noise2frames*signal1cueCong*signal2cueCong.png') %>% ggsave(width=9, height=6, dpi='retina')

```

## noise1 analyses
```{r p(chooseCue ~ noise1frames * signal1_cueCong + respFinger)}

noise1_range <- test_trials %>% filter(respPeriod == 'signal1')
noise1_range <- c(range(noise1_range$noise1frames_behav), 
                  median(noise1_range$noise1frames_behav), 
                  quantile(noise1_range$noise1frames_behav, names=F)[4])

m <- test_trials %>% filter(respPeriod == 'signal1') %>%
  glm(cueCongChoice ~ noise1frames_behav * signal1_cueCong + respFinger, ., family='binomial')

emmip(m, ~ noise1frames_behav | signal1_cueCong, type='response',at=list(noise1frames_behav=noise1_range), plotit=F) %>%
  mutate(signal1_cueCong = factor(signal1_cueCong, 
                                  levels=c('0.8 cue: incongruent vizEv', '0.8 cue: equal vizEv', '0.8 cue: congruent vizEv'))) %>%
  ggplot(aes(xvar, yvar, color= signal1_cueCong, fill=signal1_cueCong)) +
  theme_bw() + 
  geom_hline(yintercept=0.5, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.1, color=NA) +
  geom_line(linewidth=1) +
  labs(x = 'noise1 frames', y = 'p(chooseCue)', title = 'Probability of making cue-congruent choice during signal1', 
       subtitle = 'chooseCue ~ noise1frames * signal1_cueCong + respFinger')

paste0(outdir, 'noise1_regressions/pChooseCue_signal1cueCong.png') %>% ggsave(width=6, height=3)
```

```{r p(chooseCue ~ noise1frames * signal1_cueCong + respFinger)}

f <- test_trials %>% filter(respPeriod == 'signal1')
rrange = c(range(f$vizLocked_respFrame_t), median(f$vizLocked_respFrame_t))

m <- test_trials %>% filter(respPeriod == 'signal1') %>%
  glm(cueCongChoice ~ vizLocked_respFrame_t * noise1frames_behav * signal1_cueCong + respFinger, ., family='binomial')


emmip(m, vizLocked_respFrame_t ~ noise1frames_behav | signal1_cueCong, 
      type='response',at=list(noise1frames_behav=noise1_range, vizLocked_respFrame_t=rrange)) + 
  theme_bw()+ geom_hline(yintercept=0.5)


ggsave('plot.png')

+ 
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.1, color=NA) + 
  geom_hline(yintercept=0.5) 

paste0(outdir, 'noise1_regressions/pChooseCue_signal1cueCong_.png') %>% ggsave(width=6, height=3)


emmip(m, vizLocked_respFrame_t ~ noise1frames_behav | signal1_cueCong, 
      type='response',at=list(noise1frames_behav=noise1_range, vizLocked_respFrame_t=rrange), plotit=F) %>%
  mutate(signal1_cueCong = factor(signal1_cueCong, 
                                  levels=c('0.8 cue: incongruent vizEv', '0.8 cue: equal vizEv', '0.8 cue: congruent vizEv'))) %>%
  ggplot(aes(xvar, yvar, color= signal1_cueCong, fill=signal1_cueCong)) +
  theme_bw() + 
  geom_hline(yintercept=0.5, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.1, color=NA) +
  geom_line(linewidth=1) +
  facet_wrap()
  labs(x = 'noise1 frames', y = 'p(chooseCue)', title = 'Probability of making cue-congruent choice during signal1', 
       subtitle = 'chooseCue ~ noise1frames * signal1_cueCong + respFinger')

paste0(outdir, 'noise1_regressions/pChooseCue_signal1cueCong.png') %>% ggsave(width=6, height=3)
```

```{r p(chooseCue ~ noise1frames * signal1frames * signal1_cueCong + respFinger)}

m <- test_trials %>% filter(respPeriod == 'signal1') %>%
  glm(cueCongChoice ~ noise1frames_behav * signal1frames_behav * signal1_cueCong + respFinger, ., family='binomial')

emmip(m, noise1frames_behav ~ signal1frames_behav | signal1_cueCong, type='response', at=list(noise1frames_behav=noise1_range,
                                                                                             signal1frames_behav=varRange(test_trials, 'signal1frames_behav', 40)), plotit=F) %>%
  ggplot(aes(xvar, yvar, color= signal1_cueCong, fill=signal1_cueCong, group=noise1frames_behav)) +
  theme_bw() + 
  geom_hline(yintercept=0.5, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.1, color=NA) +
  geom_line(aes(linewidth=factor(noise1frames_behav))) +
  facet_wrap(~ signal1_cueCong, scales='free') +
  scale_linewidth_manual(values=c(0.5, 0.9, 1.3, 1.75)) +
  scale_color_manual(values=cueCong_colors) + scale_fill_manual(values=cueCong_colors) +
  labs(x = 'signal 1 frames', y = 'p(chooseCue)', 
       title = 'Probability of making cue-congruent choice during signal1 as a function of noise1 duration', 
       subtitle = 'chooseCue ~ signal1frames * noise1frames * signal1_cueCong + respFinger') +
  facetted_pos_scales(y = list(NULL, scale_y_continuous(breaks = c(-1, -0.75, -0.5, 0, 0.5, 0.75, 1), limits = c(-1.25, 1.25))))

paste0(outdir, 'noise1_regressions/pChooseCue_signal1cueCongOverTime.png') %>% ggsave(width=10, height=4)
```

```{r zlogRT ~ noise1frames * signal1_cueCong + respFinger}

m <- test_trials %>% filter(respPeriod == 'signal1') %>%
  lm(vizLocked_respFrame_t ~ noise1frames_behav * signal1_cueCong + respFinger, .)

mMeans <- test_trials %>% filter(respPeriod == 'signal1') %>% 
  group_by(cueType, signal1_cueCong) %>%
  summarise(m = mean(vizLocked_respFrame_t)) %>%
  group_by(cueType) %>%
  summarise(m = mean(m))

emmip(m, ~ noise1frames_behav | signal1_cueCong ,at=list(noise1frames_behav=noise1_range), plotit=F) %>%
    mutate(cueType = case_when(str_starts(signal1_cueCong, '0.5') ~ '50% cue',
                             str_starts(signal1_cueCong, '0.8') ~ '80% cue'),
           cueType = factor(cueType, levels=c('80% cue', '50% cue')),
         signal1_cueCong = factor(signal1_cueCong, levels=c('0.8 cue: incongruent vizEv', '0.8 cue: equal vizEv', '0.8 cue: congruent vizEv',
                                                            '0.5 cue: imgA vizEv', '0.5 cue: imgB vizEv', '0.5 cue: equal vizEv'))) %>%
  ggplot(aes(xvar, yvar, color= signal1_cueCong, fill=signal1_cueCong)) +
  theme_bw() + 
  geom_hline(yintercept=c(0.416, 0.410), linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.1, color=NA) +
  geom_line(linewidth=1.5) +
  facet_wrap( ~ cueType, scales='free') + 
  scale_color_manual(values=cueCong_colors) + scale_fill_manual(values=cueCong_colors) +
  labs(x = 'noise1 frames', y = 'z-scored & back-transformed respFrame-noise1frames', title = 'Effect of noise1 &  cue-evidence congruence on signal1 RT', 
       subtitle = 'vizLocked_respFrame_t ~ noise1frames * signal1_cueCong + respFinger') +
  theme(axis.title.y = element_text(size=8))

paste0(outdir, 'noise1_regressions/RT_signal1cueCong.png') %>% ggsave(width=6, height=3)
```


```{r p(chooseCue ~ noise1frames * signal1frames * signal1_cueCong + respFinger) -- computed by hand}

test_trials %>% 
  filter(respPeriod == 'signal1', is.na(cueCongChoice)==F, is.na(signal1_cueCong)==F, signal1_cueCong != '0.8 cue: equal vizEv') %>%
  mutate(signal1_quartile = cut(signal1frames_behav, breaks=quantile(signal1frames_behav, names=F, na.rm=T))) %>%
  group_by(signal1_cueCong, firstNoise_quartile, signal1_quartile, subID) %>%
  summarise(pChooseCue = mean(cueCongChoice)) %>% 
  ggplot(aes(x=signal1_quartile, y=pChooseCue, color=signal1_cueCong, fill=signal1_cueCong)) +
  theme_bw() + geom_hline(yintercept=0.5, linetype='dashed') + 
  scale_color_manual(values=cueCong_colors) + scale_fill_manual(values=cueCong_colors) +
  facet_wrap(~ signal1_cueCong) +
  stat_summary(aes(group=firstNoise_quartile, linewidth=factor(firstNoise_quartile)), fun='mean', geom='line') +
  scale_linewidth_manual(values = c(0.5, 0.9, 1.25, 1.75))

test_trials %>% 
  filter(respPeriod == 'signal1', is.na(cueCongChoice)==F, is.na(signal1_cueCong)==F, signal1_cueCong != '0.8 cue: equal vizEv') %>%
  mutate(signal1_quartile = cut(signal1frames_behav, breaks=quantile(signal1frames_behav, names=F, na.rm=T))) %>%
  group_by(signal1_cueCong, firstNoise_quartile, signal1_quartile, subID) %>%
  summarise(pChooseEv = mean(evCongChoice)) %>% 
  ggplot(aes(x=signal1_quartile, y=pChooseEv, color=signal1_cueCong, fill=signal1_cueCong)) +
  theme_bw() + geom_hline(yintercept=0.5, linetype='dashed') + 
  #scale_color_manual(values=cueCong_colors) + scale_fill_manual(values=cueCong_colors) +
  facet_wrap(~ signal1_cueCong) +
  stat_summary(aes(group=firstNoise_quartile, linewidth=factor(firstNoise_quartile)), fun='mean', geom='line') +
  scale_linewidth_manual(values = c(0.5, 0.9, 1.25, 1.75))
  
  
  

  stat_summary(aes(linewidth=firstNoise_quartile), fun='mean', geom='line')



emmip(m, noise1frames_behav ~ signal1frames_behav | signal1_cueCong, type='response', at=list(noise1frames_behav=noise1_range,
                                                                                             signal1frames_behav=varRange(test_trials, 'signal1frames_behav', 40)), plotit=F) %>%
  ggplot(aes(xvar, yvar, color= signal1_cueCong, fill=signal1_cueCong, group=noise1frames_behav)) +
  theme_bw() + 
  geom_hline(yintercept=0.5, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE), alpha=0.1, color=NA) +
  geom_line(aes(linewidth=factor(noise1frames_behav))) +
  facet_wrap(~ signal1_cueCong, scales='free') +
  scale_linewidth_manual(values=c(0.5, 0.9, 1.3, 1.75)) +
  scale_color_manual(values=cueCong_colors) + scale_fill_manual(values=cueCong_colors) +
  labs(x = 'signal 1 frames', y = 'p(chooseCue)', 
       title = 'Probability of making cue-congruent choice during signal1 as a function of noise1 duration', 
       subtitle = 'chooseCue ~ signal1frames * noise1frames * signal1_cueCong + respFinger') +
  facetted_pos_scales(y = list(NULL, scale_y_continuous(breaks = c(-1, -0.75, -0.5, 0, 0.5, 0.75, 1), limits = c(-1.25, 1.25))))

paste0(outdir, 'noise1_regressions/pChooseCue_signal1cueCongOverTime.png') %>% ggsave(width=10, height=4)
```























```{r propCorrect ~ noise1frames * signal1_cueCong + respFinger}
```



```{r p(chooseA) ~ signal1_evA * noise2 duration}

m5 <- glm(chooseA ~ signal1_evA * noise2frames_behav, noise2_df, family='binomial')
summary(m5)

# colors for plotting
colors <- RColorBrewer::brewer.pal(9,"PRGn")[4:9]

# plot result of effect of signal on p(chooseA)
m5_df <- emmip(m5, ~ noise2frames_behav | signal1_evA, type='response', 
      at=list(noise2frames_behav=varRange(noise2_nonNeutral, 'noise2frames_behav'), signal1_evA=varRange(noise2_nonNeutral, 'signal1_evA', precision=5)), plotit=F)

m5_df %>%
  filter(signal1_evA==min(signal1_evA) | signal1_evA == 0 | signal1_evA == max(signal1_evA)) %>%
  mutate(signal1_evA = factor(signal1_evA)) %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  geom_hline(yintercept=0.5, linewidth=0.15, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_evA), alpha=0.2, color=NA) +
  geom_line(aes(color=signal1_evA), linewidth=2) +
  labs(y = 'predicted p(chooseA)', x='noise2 frames', 
       title = 'effect of signal1 evidence on p(chooseA) during & after second noise') +
  #scale_color_manual(values=colors) + scale_fill_manual(values=colors) +
  guides(color=guide_legend(reverse = T), fill=guide_legend(reverse = T)) +
  ylim(0,1)
paste0(outdir, 'noise2_pChooseA_evA_regInt_extremes.png') %>% ggsave(width=8, height=4, dpi='retina')
```

```{r p(chooseB) ~ signal1_evB * noise2 duration}

# colors for plotting
colors <- RColorBrewer::brewer.pal(9,"PRGn")[4:9]

# df for choosing B
noise2_df <- noise2_df %>% mutate(chooseB = ifelse(response==2, 1, 0),
                                  signal1_evB = signal1_target2 - signal1_target1)

m6 <- glm(chooseB ~ signal1_evB * noise2frames_behav, noise2_df, family='binomial')
summary(m6)

# plot result of effect of signal on p(chooseA)
m6_df <- emmip(m6, ~ noise2frames_behav | signal1_evB, type='response', 
      at=list(noise2frames_behav=noise2_range('noise2frames_behav'), signal1_evB=noise2_range('signal1_evB', precision=5)), plotit=F)

m6_df %>%
  filter(signal1_evB==min(signal1_evB) | signal1_evB == 0 | signal1_evB == max(signal1_evB)) %>%
  mutate(signal1_evB = factor(signal1_evB)) %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  geom_hline(yintercept=0.5, linewidth=0.15, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_evB), alpha=0.2, color=NA) +
  geom_line(aes(color=signal1_evB), linewidth=2) +
  labs(y = 'predicted p(chooseB)', x='noise2 frames', 
       title = 'effect of signal1 evidence on p(chooseB) during & after second noise') +
  #scale_color_manual(values=colors) + scale_fill_manual(values=colors) +
  guides(color=guide_legend(reverse = T), fill=guide_legend(reverse = T)) +
  ylim(0,1)
paste0(outdir, 'noise2_pChooseA_evA_regInt_extremes.png') %>% ggsave(width=8, height=4, dpi='retina')

```

```{r p(chooseB) ~ cueIdx + signal1_evB * noise2frames}

m7 <- glm(chooseB ~ cueIdx * signal1_evB * noise2frames_behav, noise2_df, family='binomial', contrasts=list(cueIdx=contr.sum))
summary(m7)

# plot result of effect of signal on p(chooseA)
m7_df <- emmip(m7, signal1_evB ~ noise2frames_behav | cueIdx, type='response', 
      at=list(noise2frames_behav=noise2_range('noise2frames_behav'), signal1_evB=noise2_range('signal1_evB', precision=5)), plotit=F)

p1 <- m7_df %>%
  filter(signal1_evB==min(signal1_evB) | signal1_evB == 0 | signal1_evB == max(signal1_evB)) %>%
  mutate(signal1_evB = factor(signal1_evB)) %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  facet_wrap(~ cueIdx) +
  geom_hline(yintercept=0.5, linewidth=0.15, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_evB), alpha=0.2, color=NA) +
  geom_line(aes(color=signal1_evB), linewidth=2) +
  labs(y = 'predicted p(chooseB)', x='noise2 frames', 
       title = 'effect of signal1 evidence on p(chooseB) during & after second noise') +
  #scale_color_manual(values=colors) + scale_fill_manual(values=colors) +
  guides(color=guide_legend(reverse = T), fill=guide_legend(reverse = T)) +
  ylim(0,1)

```

```{r}
m8 <- glm(chooseA ~ cueIdx * signal1_evA * noise2frames_behav, noise2_df, family='binomial', contrasts=list(cueIdx=contr.sum))
summary(m8)

# plot result of effect of signal on p(chooseA)
m8_df <- emmip(m8, signal1_evA ~ noise2frames_behav | cueIdx, type='response', 
      at=list(noise2frames_behav=noise2_range('noise2frames_behav'), signal1_evA=noise2_range('signal1_evA', precision=5)), plotit=F)

p2 <- m8_df %>%
  filter(signal1_evA==min(signal1_evA) |signal1_evA == max(signal1_evA)) %>%
  mutate(signal1_evA = factor(signal1_evA)) %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  facet_wrap(~ cueIdx) +
  geom_hline(yintercept=0.5, linewidth=0.15, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_evA), alpha=0.2, color=NA) +
  geom_line(aes(color=signal1_evA), linewidth=2) +
  labs(y = 'predicted p(chooswA)', x='noise2 frames', 
       title = 'effect of signal1 evidence on p(chooseA) during & after second noise') +
  #scale_color_manual(values=colors) + scale_fill_manual(values=colors) +
  guides(color=guide_legend(reverse = T), fill=guide_legend(reverse = T)) +
  ylim(0,1)

p1 / p2

```

```{r}

noise2_df <- noise2_df %>% mutate(absEv = signal1_target1 - signal1_target2)

m9 <- glm(cueCongChoice ~ noise2frames_behav * trialCongruence * absEv, noise2_df, family='binomial', contrasts=list(trialCongruence=contr.sum))
summary(m9)

# plot result of effect of signal on p(chooseA)
m8_df <- emmip(m9, absEv ~ noise2frames_behav | trialCongruence, type='response', 
      at=list(noise2frames_behav=noise2_range('noise2frames_behav'), absEv=noise2_range('absEv', precision=5)), plotit=F)

m8_df %>%
  filter(absEv==min(absEv) |absEv == max(absEv)) %>%
  mutate(absEv = factor(absEv)) %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  facet_wrap(~ trialCongruence) +
  geom_hline(yintercept=0.5, linewidth=0.15, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=absEv), alpha=0.2, color=NA) +
  geom_line(aes(color=absEv), linewidth=2) +
  labs(y = 'predicted p(chooseCue)', x='noise2 frames', 
       title = 'effect of signal1 evidence on p(chooseCue) during & after second noise') +
  #scale_color_manual(values=colors) + scale_fill_manual(values=colors) +
  guides(color=guide_legend(reverse = T), fill=guide_legend(reverse = T)) +
  ylim(0,1)

```

```{r}

noise2_df <- noise2_df %>% mutate(signal1_ev = signal1_target1 - signal1_target2,
                                  signal1_ev = ifelse(response==trialTarget, signal1_ev, -1*signal1_ev),
                                  cueType = ifelse(cueIdx=='50%', 'neutral', '80%'))

m10 <- glm(evCongChoice ~ noise2frames_behav * signal1_ev * cueType, noise2_df, family='binomial')
summary(m10)

# plot result of effect of signal on p(chooseA)
m10_df <- emmip(m10, signal1_ev ~ noise2frames_behav | cueType, type='response', 
      at=list(noise2frames_behav=noise2_range('noise2frames_behav'), signal1_ev=noise2_range('signal1_ev', precision=5)), plotit=F)

p3 <- m10_df %>%
  filter(signal1_ev==min(signal1_ev) |signal1_ev == max(signal1_ev)) %>%
  mutate(signal1_ev = factor(signal1_ev),
         cueType = factor(cueType), levels=c('neutral', '80%')) %>%
  ggplot(aes(x=xvar, y=yvar)) +
  theme_bw() +
  facet_wrap(~ cueType) +
  geom_hline(yintercept=0.5, linewidth=0.15, linetype='dashed') +
  geom_ribbon(aes(ymin=yvar-SE, ymax=yvar+SE, fill=signal1_ev), alpha=0.2, color=NA) +
  geom_line(aes(color=signal1_ev), linewidth=2) +
  labs(y = 'predicted p(chooseAccording to Evidence)', x='noise2 frames', 
       title = 'effect of signal1 evidence on p(chooseAccording to Evidence) during & after second noise') +
  #scale_color_manual(values=colors) + scale_fill_manual(values=colors) +
  guides(color=guide_legend(reverse = T), fill=guide_legend(reverse = T)) +
  ylim(0,1)

p3 | (p1 / p2)
```

```{r}

test_trials %>%
  filter(respPeriod == 'noise1') %>%
  mutate(cueType = ifelse(cueIdx=='50%', '50%', '80%')) %>%
  ggplot(aes(x=noise1frames_behav, y=cueCongChoice)) +
  theme_bw() + geom_hline(yintercept=0.5, linewidth=0.15) +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) +
  facet_wrap(~ cueType)
```

```{r p(chooseCue | total noise)}

# group
noise2_nonNeutral %>%
  ggplot(aes(x=totalNoise, y=cueCongChoice)) +
  theme_bw() +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
  labs(title='logistic regression', subtitle= 'cueCongChoice ~ totalNoise')

# individual
noise2_nonNeutral %>%
  ggplot(aes(x=totalNoise, y=cueCongChoice)) +
  theme_bw() +
  facet_wrap(~ subID, nrow=2) +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
  labs(title='logistic regression', subtitle= 'cueCongChoice ~ totalNoise')
```

```{r trying things out, tidy up tmrw}

df <- test_trials %>% 
  filter(respPeriod == 'noise2' | respPeriod == 'signal2') %>% 
  filter(congruent!='neutral') %>%
  mutate(cueCong_noise2RT = ifelse(cueCongChoice==1 & secondNoiseRT==1, 1, 0))

df %>%
  ggplot(aes(x = noise2frames_design, y = cueCong_noise2RT)) +
  theme_bw() +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial'))

df %>% 
  filter(respPeriod == 'noise2') %>%
  ggplot(aes(x = noise2frames_design, y = cueCongChoice)) +
  theme_bw() +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial'))

test_trials %>%
  filter(respPeriod == 'signal2' | respPeriod == 'noise2') %>%
  ggplot(aes(x=totalNoise, y=cueCongChoice)) +
  theme_bw() + 
  geom_point(shape = '|') + 
  geom_smooth(method = 'glm', method.args=list(family='binomial'))


#### rt analysis
test_trials %>%
  mutate(cueCongChoice = factor(cueCongChoice, levels=c(0,1), labels=c('cue incongruent resp', 'cue congruent resp'))) %>%
  filter(respPeriod == 'signal2') %>%
  ggplot(aes(x = noise2frames_design, y = zlogRT)) +
  theme_bw() +
  geom_point(alpha=0.5) +
  stat_smooth(method = 'lm') + 
  facet_wrap(~ cueCongChoice) +
  labs(title = 'signal 2 responses only')

test_trials %>%
  mutate(cueCongChoice = factor(cueCongChoice, levels=c(0,1), labels=c('cue incongruent resp', 'cue congruent resp'))) %>%
  filter(respPeriod == 'signal2' | respPeriod == 'noise2') %>%
  ggplot(aes(x = noise2frames_design, y = zlogRT)) +
  theme_bw() +
  geom_point(alpha=0.5) +
  stat_smooth(method = 'lm') + 
  facet_wrap(~ cueCongChoice) +
  labs(title = 'noise2 & signal 2')

test_trials %>%
  mutate(cueCongChoice = factor(cueCongChoice, levels=c(0,1), labels=c('cue incongruent resp', 'cue congruent resp')),
         noise2frames_designZ = scale(noise2frames_design)) %>%
  filter(respPeriod == 'signal2' | respPeriod == 'noise2') %>%
  ggplot(aes(x = noise2frames_designZ, y = zlogRT)) +
  theme_bw() +
  geom_point(alpha=0.5) +
  stat_smooth(method = 'lm') + 
  facet_wrap(~ cueCongChoice) +
  labs(title = 'noise2 & signal 2')
```

```{r p(chooseCue | noise2 duration && noise2 response)}

## filter out irrelevant trials
noise2_nonNeutral2 <- test_trials %>% filter(respPeriod=='noise2') %>% filter(congruent !='neutral')

# plot raw data
p1 <- noise2_nonNeutral2 %>%
  mutate(noise2_quartile = cut(noise2frames_behav, quantile(noise2frames_behav, labels=F))) %>%
  group_by(subID, noise2_quartile) %>%
  summarise(pCue = mean(cueCongChoice)) %>%
  filter(is.na(noise2_quartile)==F) %>%
  ggplot(aes(y=pCue, x=noise2_quartile, label=subID)) +
  theme_bw() +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  geom_line(aes(group=subID, color=factor(subID)), alpha=0.5, linewidth=1) +
  stat_summary(fun.data='mean_se', geom='pointrange', fatten=6) +
  #geom_text(vjust=-0.5, hjust=0.3) +
  labs(y = 'proportion of choices == cue', title = 'responses made only during second noise', subtitle='errorbars: +/- 1 SEM')

# plot simple linear regression
p2 <- noise2_nonNeutral2 %>%
  ggplot(aes(x=noise2frames_behav, y=cueCongChoice)) +
  theme_bw() +
  geom_jitter(alpha=0.4, height=0.01) +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) + 
  labs(title='generalized linear regression: noise2 responses only', subtitle= 'cueCongChoice ~ noise2frames')

p1 + p2
paste0(outdir, 'noise2_reg_noise2resp.png') %>% ggsave(width=10, height=4, dpi='retina')

# plot single regression per subject
noise2_nonNeutral2 %>% 
  mutate(subID = paste0('subID=', subID)) %>%
  ggplot(aes(x=noise2frames_behav, y=cueCongChoice)) +
  theme_bw() +
  facet_wrap(~ subID, nrow=2) +
  geom_point(shape='|') +
  geom_smooth(method = 'glm', method.args=list(family='binomial')) +
  labs(title='generalized linear regression: noise 2 responses only', subtitle= 'cueCongChoice ~ noise2frames')
paste0(outdir, 'noise2_regPerSubject_noise2resp.png') %>% ggsave(width=8, height=6, dpi='retina')

rm(p1, p2)
```

```{r p(chooseCue | noise1 duration && noise1 response)}
# filter data
m4_df <- test_trials %>% filter(respPeriod == 'noise1')

# plot raw data
p1 <- m4_df %>%
  mutate(noise1_quartile = cut(noise1frames_behav, quantile(noise1frames_behav, labels=F))) %>%
  group_by(subID, noise1_quartile) %>%
  summarise(pCue = mean(cueCongChoice)) %>%
  filter(is.na(noise1_quartile)==F) %>%
  ggplot(aes(y=pCue, x=noise1_quartile, label=subID)) +
  theme_bw() +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  #geom_line(aes(group=subID, color=factor(subID)), alpha=0.5, linewidth=1) +
  stat_summary(fun.data='mean_se', geom='pointrange', fatten=6) +
  labs(y = 'proportion of choices == cue', title = 'responses made only during first noise', subtitle='errorbars: +/- 1 SEM')

m4_df %>%
  mutate(noise1_quartile = cut(noise1frames_design, quantile(noise1frames_design, labels=F))) %>%
  group_by(subID, noise1_quartile) %>%
  summarise(pCue = mean(cueCongChoice)) %>%
  filter(is.na(noise1_quartile)==F) %>%
  ggplot(aes(y=pCue, x=noise1_quartile, label=subID)) +
  theme_bw() +
  geom_hline(yintercept = 0.5, linetype='dashed') +
  #geom_line(aes(group=subID, color=factor(subID)), alpha=0.5, linewidth=1) +
  stat_summary(fun.data='mean_se', geom='pointrange', fatten=6) +
  labs(y = 'proportion of choices == cue', title = 'responses made only during first noise', subtitle='errorbars: +/- 1 SEM')

```

```{r RTs & accuracy for post-noise1 responses}
### RTs
inferenceData %>% 
  filter(catch_trial==0, respFrame > noise1frames_behav) %>%
  mutate(cueType = ifelse(congruent=='neutral', '50%', '80%')) %>%
  group_by(subID, cueType, accuracyFactor) %>%
  summarise(meanRT = mean(zlogRT)) %>%
  ggplot(aes(x=cueType, y=meanRT)) + 
  facet_wrap(~ accuracyFactor) +
  theme_bw() +
  geom_hline(yintercept=0) +
  stat_summary(fun = 'mean', geom='col', fill='lightblue', color='black') +
  stat_summary(fun.data = 'mean_se', geom='pointrange') 

paste0(outdir, 'meanRTs.png') %>% ggsave(width=6, height=2.5, dpi='retina')

### accuracy
inferenceData %>% 
  filter(catch_trial==0, respFrame > noise1frames_behav) %>%
  mutate(cueType = ifelse(congruent=='neutral', '50%', '80%')) %>%
  group_by(subID, cueType) %>%
  summarise(propCorrect = mean(accuracy, na.rm=T)) %>%
  ggplot(aes(x=cueType, y=propCorrect)) + 
  theme_bw() +
  geom_hline(yintercept=0.5) +
  stat_summary(fun = 'mean', geom='col', fill='lightblue', color='black') +
  stat_summary(fun.data = 'mean_se', geom='pointrange', fatten=1, size=1) +
  ylim(0,1)

paste0(outdir, 'propCorrect.png') %>% ggsave(width=6, height=2.5, dpi='retina')
```

```{r probability of choosing cue-dominant target in noise1}

p1 <- inferenceData %>%
  filter(firstNoiseRT==1) %>%
  group_by(subID) %>%
  ggplot(aes(x=firstNoise_quartile, y=cueCongChoice)) +
  theme_bw() + 
  facet_wrap(~ catch_trial_cat) + 
  geom_hline(yintercept=0.5, linewidth=0.1) +
  stat_summary(fun.data='mean_se', geom='ribbon', color=NA, alpha=0.1) +
  stat_summary(fun='mean', geom='line', linewidth=1) +
  labs(x='first noise quartile', y='proportion of cue-congruent choices', title='proportion of cue-congruent choices made during first noise period') +
  ylim(0,1)

p2 <- inferenceData %>%
  filter(firstNoiseRT==1) %>%
  group_by(subID, congruent) %>%
  ggplot(aes(x=firstNoise_quartile, y=cueCongChoice, color=congruent, fill=congruent)) +
  theme_bw() + 
  facet_wrap(~ catch_trial_cat) + 
  geom_hline(yintercept=0.5, linewidth=0.1) +
  stat_summary(fun.data='mean_se', geom='ribbon', color=NA, alpha=0.1) +
  stat_summary(fun='mean', geom='line', linewidth=1) +
  ylim(0,1) +
  theme(axis.title = element_blank())

p1 | p2

paste0(outdir, 'pCueChoice_noise1.png') %>% ggsave(width=8, height=4, dpi='retina')

rm(p1, p2)
```

```{r propCorrect during second noise}

inferenceData %>%
  filter(secondNoiseRT==1) %>%
  mutate(trialCongruence = factor(trialCongruence, levels=c('incongruent', 'neutral', 'congruent'))) %>% 
  group_by(subID, trialCongruence, secondNoise_quartile) %>%
  ggplot(aes(x=secondNoise_quartile, y=accuracy, fill=trialCongruence, color=trialCongruence)) +
  theme_bw() + 
  facet_wrap(~ catch_trial_cat) + 
  geom_hline(yintercept=0.5, linewidth=0.1) +
  stat_summary(fun.data='mean_se', geom='ribbon', color=NA, alpha=0.1) +
  stat_summary(fun='mean', geom='line', linewidth=1) +
  labs(x='second noise quartile', y='proportion correct', title='congruence = evidence dominated by cue-dominant image') +
  ylim(0,1)
paste0(outdir, 'secondNoiseAcc_evCong.png') %>% ggsave(width=8, height=4, dpi='retina')

inferenceData %>%
  filter(secondNoiseRT==1) %>%
  mutate(trialCongruence = factor(trialCongruence, levels=c('incongruent', 'neutral', 'congruent')),
         oldAccuracy = ifelse(response==trueTarget, 1, 0)) %>% 
  group_by(subID, congruent, secondNoise_quartile) %>%
  ggplot(aes(x=secondNoise_quartile, y=oldAccuracy, fill=congruent, color=congruent)) +
  theme_bw() + 
  facet_wrap(~ catch_trial_cat) + 
  geom_hline(yintercept=0.5, linewidth=0.1) +
  stat_summary(fun.data='mean_se', geom='ribbon', color=NA, alpha=0.1) +
  stat_summary(fun='mean', geom='line', linewidth=1) +
  labs(x='second noise quartile', y='accuracy defined wrt intended target', title='congruence = match between cue & experimenter-intended target') +
  ylim(0,1)
paste0(outdir, 'secondNoiseAcc_expCong.png') %>% ggsave(width=8, height=4, dpi='retina')


inferenceData %>%
  filter(secondNoiseRT==1) %>%
  mutate(trialCongruence = factor(trialCongruence, levels=c('incongruent', 'equal evidence', 'congruent')),
         oldAccuracy = ifelse(response==trueTarget, 1, 0),
         cueIdx = factor(cueIdx, levels=c(1,2,3), labels=c('80% A', '80% B', '50%'))) %>% 
  group_by(subID, cueIdx, secondNoise_quartile) %>%
  ggplot(aes(x=secondNoise_quartile, y=oldAccuracy, fill=trialCongruence, color=trialCongruence)) +
  theme_bw() + 
  facet_grid(cueIdx ~ catch_trial_cat) + 
  geom_hline(yintercept=0.5, linewidth=0.1) +
  stat_summary(fun.data='mean_se', geom='ribbon', color=NA, alpha=0.1) +
  stat_summary(fun='mean', geom='line', linewidth=1) +
  labs(x='second noise quartile', y='accuracy defined wrt intended target', title='experimenter-defined congruence') +
  ylim(0,1)
```

```{r mixed-effects logistic regressions on choices}

test_trials <- inferenceData %>%
  filter(catch_trial==0, is.na(response)==F) %>%
  mutate(choose1 = ifelse(response==1, 1, 0),
         cueIdx = factor(cueIdx, levels=c('3', '1', '2')))
  
## looking just at effect of cue
m1 <- glmer(choose1 ~ cueIdx + (1|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m1)

m2 <- glmer(choose1 ~ cueIdx + (1+cueIdx|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m2)

## looking at effect of cue as a function of first noise duration
m3 <- glmer(choose1 ~ cueIdx + noise1frames_z + (1|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m3)

## looking at effect of cue as a function of second noise duration
m4 <- glmer(choose1 ~ cueIdx + noise2frames_z + (1|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m4)

m5 <- glmer(choose1 ~ cueIdx * noise2frames_z + (1|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m5)

## looking at effect of cue as a function of total noise
m6 <- glmer(choose1 ~ cueIdx + totalNoise_z + (1|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m6)

m7 <- glmer(choose1 ~ cueIdx * totalNoise_z + (1|subID), data=test_trials, family = binomial(link = 'logit'))
summary(m7)
```
